/* 
Decode binary log files generated in Saleae Logic to GMLAN frames. 

Input files are CSV with a column for timestamp and binary value. 
New lines are only created by a logical level transition. 

This code will use internal definitions for bus BAUD and header values to produce 
an output CSV which breaks up the decoded binary into rows with columns delineating; 

    SOF         BUS DOMINANT-LOGICAL 0
    Padding     (Bits 0-2)
    Priority    (Bits 3-5)
    Arbitration (Bits 6-18)
    ECU ID      (Bits 19-31)
    Data0       ()
    Data1
    ...
    CRC
    ACK
    EOF         BUS RECESSIVE-LOGICAL 1

Some notes; bitstreams are parsed in byte qunatizations, so the first 3 bits of the 29-bit
identifier are always padding. This decoder ignores their existence. 

----------PHYSICAL BUS DEFINITIONS--------
DOMINANT = LOGICAL 0 = BUS HIGH = 5Vdiff 
RECESSIVE = LOGICAL 1 = BUS LOW = 0Vdiff 

----------BAUD RATE AND TIMING------------
GMLANHS buses run at 500kBaud or 500,000 bits per second. This yields a bit period
of 2us. These values are stored as tPeriod.

GMLANLS on the other hand, single-wire CAN, runs at a mere 33.3kBps giving it tPeriod = 30us

Change the tPeriod value depending on input log baud. 


----------CAN FRAME STRUCTURE-------------
The first bit of bus dominant "0" after a period of recessive "1" is the start of frame. 

After tPeriod seconds have elapsed since the transition of 1 --> 0 the message structures will 
begin populating. Message arrays will populte until the end of the frame, at which time the

Following the SOF, the program will count in tPeriod incriments until the EOF is detected. 

An End of Frame of EOF sequence is generated by at least 7 bits of recessive, 1, state. 

We have identified the necessity for a GMLANHS object, which contains the following fields; 
    Priority
    Arbitration ID
    ECU ID
    Message Data (up to 8 bytes)
    ACK

Note that the message data may be extended, as notated by a special flag. This decoding method does not 
attempt to account for extended messages, and only looks at a 29-bit header, followed by 8 data bits, with
ACK and CRC bits following the data bytes, before the EOF sequence. 

For future reference, a slightly better way to accomplish this would to have been using field objects instead
of duplicating the logic in the fill_xxxx methods. Only three methods but this could have been a slight 
optimizaiton. 

-----------29BIT GMLANHS FRAME STRUCTURE-------------

0 = Start Bit   
X   = UNUSED
X   = UNUSED
X   = UNUSED

*/



#include "decode_binary.h"
#include <iostream>
#include <fstream>
#include <tgmath.h>
using namespace std; 

// definitions for transition tracking. Note that oldLvl represents the logic on interval newTime - oldTime 
// Also note that CANH is an inverted signal, so a binary 1 in the document turns into a logical 0. 
float oldTime = 0.0000;
bool oldLvl = 0; 
float newTime = 0.0000;
bool newLvl = 0;
bool frameOn = false; 

// timing definitions 
float tPeriod = 0.000002;         // period in seconds. 

// Input and output file definitions 
ifstream binaryData ("decodeData.csv");
std::ofstream decodedData ("GMLAN_MESSAGES.csv");

// message constructs 
uint16_t priority = 0; 
uint16_t arbID = 0; 
uint16_t ecuID = 0;
uint16_t data[8];

// keeps track of the number of bits entered thus far in each of these fields  
uint8_t pri_len = 3;        
uint8_t arb_len = 13;
uint8_t ecu_len = 12; 
uint8_t dataByte = 0; 
uint8_t nEmpty = pri_len;       // not sure if we need this...    


int main() {    
    
    cout << "Opened decodeData.csv..." << '\n';
    cout << "Printing the first line of decodeData.csv..." << '\n';
    if(binaryData.good()) {
        string line;
        getline(binaryData, line);    
        cout << line << '\n'; 
    }
    
    // need to prime the time marker with the first entry. 
    string startTimeString;
    string startLvlString;
    getline(binaryData, startTimeString, ','); 
    getline(binaryData, startLvlString);
    oldTime = std::stof(startTimeString);
    newTime = oldTime;
    if(std::stoi(startLvlString) > 0) {
        oldLvl = 1; 
        newLvl = 1;
    } else {
        oldLvl = 0;
        oldLvl = 0; 
    }

    // print the header to the output file 
    print_header();

    // get rows until the SOF is true, clears any partial messages at the beginning of the file.  
    while(!sof()){
        getRow();
        cout << "looping until SOF" << std::endl;
    }

    // get rows until the data is no longer good 
    while(binaryData.good()){
        if(sof()){
            cout << "start of frame, populating fields" << '\n';
            // if the SOF is just a single bit, then get a new row and begin the calls 
            if(numBits() < 2) {
                getRow();      
                cout << "entering fill priority after getrow" << '\n';
                fill_priority(numBits(), pri_len);
            } else { // otherwise just decriment the nBits by the start bit length and begin the calls  
                cout << "entering fill priority" << '\n';
                fill_priority(numBits()-1, pri_len);
            }
            print_line();
            // once all of the recursive sections have finished, print this to a new line in the output file.   
        } else {
            getRow();
        }
    }
    cout << "finished the decoding process..." << "\n";
}

/*  Fills the priority field by recusring through lines in the binary log file. 
 *  PRECONDS:   nBits to add to the priority field 
 *              nEmpty bits in the priority field
 *  POSTCOND:    number of remaining bits, negative if overflow
 */ 
int fill_priority(int nBits, int nEmpty){
    int dec_eq = pow(2,nEmpty) - 1;
    if(nBits > nEmpty) {            // Overflow  
        if(oldLvl == 0) {
           priority |= dec_eq;
        } 
        nBits -= nEmpty; 
        cout << "finished populating priority field, moving to arbitration" << std::endl;
        return fill_arbitration(nBits, arb_len);        // move on to the next field 
    } else if (nBits < nEmpty) {    // Underflow
        priority = priority << (nEmpty - nBits); 
        if(oldLvl == 0){
           priority |= dec_eq;
        }
        getRow();
        nEmpty -= nBits; 
        return fill_priority(numBits(), nEmpty);        // recurse on this method 
    } else {                          // Unity 
        priority = priority << (nEmpty - nBits); 
        if(oldLvl == 0){
           priority |= dec_eq;
        }
        getRow();
        cout << "finished populating priority field, moving to arbitration" << std::endl;
        return fill_arbitration(numBits(),arb_len);     // move on to the next field 
    }
}

/*  Fills the arbitration field of the frame.  
 *  PRECONDS:   nBits to add 
 *              nEmpty bits 
 *  POSTCONDS:  number of feftover bits. 
 */
int fill_arbitration(int nBits, int nEmpty){
    int dec_eq = pow(2,nEmpty) - 1;
    if(nEmpty > nBits) {            // Overflow 
        if(oldLvl == 0) {
            arbID |= dec_eq;
        }
        nBits -= nEmpty; 
        cout << "finished populating arbitration field, moving to ecu" << std::endl;
        return fill_ecu_id(nBits, ecu_len);
    } else if (nBits > nEmpty) {    // Underflow 
        cout << "in the arb underflow case, nbits is " << nBits << " and nEMpty is " << nEmpty << std::endl;
        arbID = arbID << (nEmpty - nBits);
        if(oldLvl == 0){
            arbID |= dec_eq;
        }
        getRow();
        nEmpty -= nBits;
        return fill_arbitration(numBits(), nEmpty);
    } else {                        // Unity 
        arbID = arbID << (nEmpty - nBits);
        if(oldLvl == 0){
            arbID |= dec_eq;
        }
        cout << "finished populating arbitration field, moving to ecu" << std::endl;
        getRow();
        return fill_ecu_id(numBits(), ecu_len);
    }
}

/*  Fills the ecu ID field of the frame.  
 *  PRECONDS:   nBits to add 
 *              nEmpty bits 
 *  POSTCONDS:  number of feftover bits. 
 */
int fill_ecu_id(int nBits, int nEmpty){
    int dec_eq = pow(2,nEmpty) - 1;
    if(nBits > nEmpty) {            // Overflow
        if(oldLvl == 0) {
            ecuID |= dec_eq;
        }
        nBits -= nEmpty; 
        cout << "finished populating ecu field, moving to data" << std::endl;
        return fill_data(nBits,8); 
    } else if (nBits < nEmpty) {    // Underflow 
        ecuID = ecuID << (nEmpty - nBits);
        if (oldLvl == 0) {
            ecuID |= dec_eq;
        }
        getRow();
        nEmpty -= nBits;
        return fill_ecu_id(numBits(),nEmpty);
    } else {                        // Unity 
        ecuID = ecuID << (nEmpty - nBits); 
        if(oldLvl == 0){
            ecuID |= dec_eq;
        } 
        getRow();
        cout << "finished populating ecu field, moving to data" << std::endl;
        return fill_data(numBits(),8);
    }
}

/*  Follows the same recursive call structure as the rest of the program. 
 *  Specifically uses an additional field to track which byte is being written. 
 *  Fills out the data bits. 
 *  PRECONDS:   nBits = number of bits at the current logic level 
 *              nEmpty = number of empty spaces to fill in the current field
 *              dataByte = the current byte being written 
 */ 
int fill_data(int nBits, int nEmpty){
    int dec_eq = pow(2,nEmpty) - 1;
    if(nBits > nEmpty) {            // Overflow
        if(oldLvl == 0) {
            data[dataByte] |= dec_eq;
        }
        nBits -= nEmpty; 
        // either need to move to the next byte... 
        if(dataByte < 7) {
            cout << "finished populating dataByte " << dataByte << std::endl;
            dataByte++;
            return fill_data(nBits, 8);  
        } else {            // if we're on the 7th byte then we should move onto the next field or stop. 
            return 0;       // stopping for now so we can test this procedure...
        }
    } else if (nBits < nEmpty) {    // Underflow 
        data[dataByte] = data[dataByte] << (nEmpty - nBits);
        if (oldLvl == 0) {
            data[dataByte] |= dec_eq;
        }
        getRow();
        nEmpty -= nBits;
        return fill_data(numBits(),nEmpty);
    } else {                        // Unity 
        data[dataByte] = data[dataByte] << (nEmpty - nBits); 
        if(oldLvl == 0){
            data[dataByte] |= dec_eq;
        } 
        if(dataByte < 7) {
            getRow();
            cout << "finished populating dataByte " << dataByte << std::endl;
            dataByte++;
            return fill_data(numBits(),8);
        } else {
            return 0;       // stopping for now so we can test this procedure...
        }
    }
}

/*  Checks transition between previous level and current level as 0 --> 1
 *  Checks whether or not the time between the previous transition 1--> 0 is > 7 * tPeriod
 */
bool sof(){
    cout << "checking SOF" << std::endl;
    //check if the previous value was recessive and the current value is dominant. 
    if(oldLvl == 0 && newLvl == 1) {
        float tDelta = newTime - oldTime; 
        cout << "tDelta = " << tDelta << '\n';
        if(tDelta > (7 * tPeriod)){
            cout << "start of frame!" << '\n';
            // if we're at the beginning of a frame, or we detected that the trasntition is there.
            // i.e. ______---- so old is low and new is high, we need only consider the new transition
            // so we should get a new row. 
            getRow();
            return true;
        }
    } else {
        cout << "improper transition edge" << std::endl;
    }
    return false; 
}

// Updates the time and level state parameters by reading them from the file. 
void getRow(){
    cout << "getting a new row" << std::endl;
    oldTime = newTime; 
    oldLvl = newLvl;
    string newTimeString;
    string newLvlString;
    getline(binaryData, newTimeString, ','); 
    getline(binaryData, newLvlString);
    newTime = std::stof(newTimeString);
    if(std::stoi(newLvlString) > 0) {
        newLvl = 1; 
    } else {
        newLvl = 0; 
    }
    // csv format for comparison with input
    //cout << newTime << ", " << newLvl << '\n';
}

// Returns the number of bits on the last interval imported. 
int numBits(){
    float tDelta = newTime - oldTime;
    cout << "tDelta is " << tDelta << std::endl; 
    uint16_t nBits = ceil(tDelta / tPeriod);
    cout << "nBits is " << nBits << std::endl;
    return nBits;
}

/*  Prints the current fields as a frame to a new file. 
 *  Resets all of the global frame fields for next read. 
 */
void print_line(){
    decodedData << priority << "," << arbID << "," << ecuID << "," << data << std::endl;
    cout << "printed a line to the outfile" << '\n';
    // reset all of the fields 
    priority = 0; 
    arbID = 0; 
    ecuID = 0;
    std::fill_n(data, 8, 0);   
}

// Prints the headers for the csv output.  
void print_header(){
  decodedData << "Priority" << "," << "Arb ID" << "," << "ECU ID" << "," << "Data" << std::endl;
  cout << "printed the header" << '\n';
}